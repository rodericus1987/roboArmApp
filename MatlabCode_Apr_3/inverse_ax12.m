%  This function returns q, the 1x4 vector of joint angles solving
%  the inverse kinecmatics problem.
%
%  usage: q = inverse_ax12(myrobot, X)
%
%  X is the 4x4 homogeneous transformation matrix containing the desired
%  position and orientation of the end effector.
%
%  myrobot is the robot structure generated by your function myax12

function q = inverse_ax12(myrobot, X, numJoints, config, q4)

%  obtaining DH parameters from myrobot structure
dh = myrobot.dh;
alpha = dh(:,1);
a = dh(:,2);
d = dh(:,4);

% setup desired position and orientation variables
oc = X;
% R = X(1:3,1:3);

% oc = O - R*[0; 0; d(6)];

% define intermediary calculations
r = sqrt(oc(1)^2 + oc(2)^2);
s = oc(3) - d(1);
t = sqrt((r-a(1))^2 + s^2);
l = sqrt(d(4)^2 + a(3)^2);
D = (a(2)^2 + l^2 - t^2)/(2*a(2)*l);    
phi = atan2(a(3), d(4));

if numJoints == 2
    q(1) = atan2(oc(2),oc(1));
    q(2) = atan2(s, r - a(1));
elseif numJoints == 3
    % calculate joint variables 
    q(1) = atan2(oc(2),oc(1));
    D = (a(2)^2 + t^2 - l^2)/(2*a(2)*t);  
    
    % U if o4 is higher than o2
    if config == 'U'
        q(2) =  atan2(real(-sqrt(1-D^2)),D)  + atan2(s, r-a(1));
    elseif config == 'D'
        q(2) =  atan2(real(sqrt(1-D^2)),D)  + atan2(s, r-a(1));
    end
    
    if r <= a(1)
        q(2) = pi/2 + atan2(real(sqrt(1-D^2)), D) + atan2(a(1) - r,s);
    end
    
    q(3) = pi/2 - q(2) + atan2(s - a(2)*sin(q(2)), r - a(1) - a(2)*cos(q(2))) - phi;
      
    q(4) = q4;
    
%     if abs((r-a(1)) - (a(2) + d(4))) < 2
%         q(2) = 0;
%         q(3) = pi/2;
%     end
        
end

% if numJoints == 2
%     q(1) = atan2(oc(2),oc(1));
%     q(2) = atan2(s, r - a(1));
% elseif numJoints == 3
%     % calculate joint variables 
%     q(1) = atan2(oc(2),oc(1))
%     
%     if (r - (a(1)+a(2)+a(3))) > 30
%         q(3) = atan2(real(sqrt(1-D^2)),D)  - phi  - pi/2;
%     else
%         q(3) = pi/2;
%     end
%     q(2) = atan2(s, r - a(1)) + atan2(l*cos(q(3)+phi), a(2) + l*sin(q(3)+phi));
% end

end



